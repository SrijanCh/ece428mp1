package main
import(
		"fmt"
	    "net/rpc"
	    "os"
		"querier"
    	"bufio"
    	"container/list"
	  )

//The main; this one greps the provided vmlog files given to us FOR JOEY
func main(){
	//Make a new list representing IPs
	ips := list.New()

	//Open our prebuilt list for reading from
	file, err := os.Open("../iptables.txt")
	defer file.Close()

	//Error handling
	if err != nil {
    	fmt.Println("Error opening file")
    	return	
	}

	//Copy the IPs in the list one by one onto our list
	reader := bufio.NewReader(file)
	var line string
	for {
    	line, err = reader.ReadString('\n')
    	ips.PushBack(line)
    	if err != nil {
        	break
    	}
    }

    //Call our grepping function on each IP;
    var i int = 1 //For picking the correct VMLog to grep
    for addr := ips.Front(); addr != nil; addr = addr.Next() {
		var data string = " "	//Start with an empty string

		//Pass in each argument and append them to a space-separated string
		for j := 1; j < len(os.Args); j++{
			data += os.Args[j] + " "
		}
		
		var s_addr string = fmt.Sprintf("%v", addr.Value) //Get the IP address as a string (because lists in Go are trash)
		if len(s_addr) - 1 < 0{
			continue //If there's no IP address, just keep going
		}

		var filep string = fmt.Sprintf("vm%d.log", i) //The file to grep is the VM's associated log file

		rval := joey_homegrep(s_addr[:len(s_addr)-1], data, filep); //MAKE SURE TO DISCARD THE \n AT THE END OF EACH IP

		//If there was an error, report but DO NOT CRASH
		if rval == 1 {
			fmt.Printf("Failed to connect to %s\n", addr.Value)
		}
		if rval == 2 {
			fmt.Printf("RPC failed at %s\n", addr.Value)
		}

		i++
	}
}

//	This grep greps the machine.i.logs generated by us.
// 	Args: addr = address of machine to grep
//		  arg = the arguments to the grep, flags and everything
//	Returns: 0 if successful, 1 if connection refused, 2 if RPC failed
func loggrep(addr, arg string) int{
	client, err := rpc.DialHTTP("tcp", addr + ":3074") //Connect to given address

	//If connection fails return error
	if err != nil {
		return 1
	}

	// Synchronous call
	var args = querier.Args{Data: arg, Filepath: "/home/srijanc2/machine.i.log"} //Create the args gob to send over to the RPC

	var reply string //Create a container for our results
	err = client.Call("Querier.Grep", args, &reply) //Make the remote call
	
	//If the remote call fails report error
	if err != nil {
		return 2
	}

	fmt.Printf("%s\n", reply) //Dump our result into stdout
	return 0 //success
}

//	This grep greps the on the raw args we provide.
// 	Args: addr = address of machine to grep
//		  arg = the arguments to the grep, flags and everything
//		  filepath = filepath ON THE MACHINE we want to grep
//	Returns: 0 if successful, 1 if connection refused, 2 if RPC failed
func rgrep(addr, arg, filepath string) int{
	client, err := rpc.DialHTTP("tcp", addr + ":3074") //Connect to given address
	//If connection fails return error
	if err != nil {
		return 1
	}
	// Synchronous call
	var args = querier.Args{Data: arg, Filepath: filepath} //Create the args gob to send over to the RPC
	var reply string //Create a container for our results
	err = client.Call("Querier.Grep", args, &reply) //Make the remote call
	//If the remote call fails report error
	if err != nil {
		return 2
	}
	fmt.Printf("%s\n", reply) //Dump our result into stdout
	return 0 //success
}

//	This grep greps the filepath RELATIVE TO HOME (starting from home)
// 	Args: addr = address of machine to grep
//		  arg = the arguments to the grep, flags and everything
//		  filepath = filepath ON THE MACHINE we want to grep from HOME
//	Returns: 0 if successful, 1 if connection refused, 2 if RPC failed
func homegrep(addr, arg, filepath string) int{
	client, err := rpc.DialHTTP("tcp", addr + ":3074") //Connect to given address
	//If connection fails return error
	if err != nil {
		return 1
	}
	// Synchronous call
	var args = querier.Args{Data: arg, Filepath: "/home/srijanc2/" + filepath} //Create the args gob to send over to the RPC
	var reply string //Create a container for our results
	err = client.Call("Querier.Grep", args, &reply) //Make the remote call
	//If the remote call fails report error
	if err != nil {
		return 2
	}
	fmt.Printf("%s\n", reply) //Dump our result into stdout
	return 0 //success
}


//	This grep greps the machine.i.logs generated by us ON JOEY'S ACCOUNT.
// 	Args: addr = address of machine to grep
//		  arg = the arguments to the grep, flags and everything
//	Returns: 0 if successful, 1 if connection refused, 2 if RPC failed
func joey_loggrep(addr, arg string) int{
	client, err := rpc.DialHTTP("tcp", addr + ":3074") //Connect to given address

	//If connection fails return error
	if err != nil {
		return 1
	}

	// Synchronous call
	var args = querier.Args{Data: arg, Filepath: "/home/jbahary2/machine.i.log"} //Create the args gob to send over to the RPC

	var reply string //Create a container for our results
	err = client.Call("Querier.Grep", args, &reply) //Make the remote call
	
	//If the remote call fails report error
	if err != nil {
		return 2
	}

	fmt.Printf("%s\n", reply) //Dump our result into stdout
	return 0 //success
}


//	This grep greps the filepath RELATIVE TO HOME (starting from home) ON JOEY'S ACCOUNTS
// 	Args: addr = address of machine to grep
//		  arg = the arguments to the grep, flags and everything
//		  filepath = filepath ON THE MACHINE we want to grep from HOME
//	Returns: 0 if successful, 1 if connection refused, 2 if RPC failed
func joey_homegrep(addr, arg, filepath string) int{
	client, err := rpc.DialHTTP("tcp", addr + ":3074") //Connect to given address
	//If connection fails return error
	if err != nil {
		return 1
	}
	// Synchronous call
	var args = querier.Args{Data: arg, Filepath: "/home/jbahary2/" + filepath} //Create the args gob to send over to the RPC
	var reply string //Create a container for our results
	err = client.Call("Querier.Grep", args, &reply) //Make the remote call
	//If the remote call fails report error
	if err != nil {
		return 2
	}
	fmt.Printf("%s\n", reply) //Dump our result into stdout
	return 0 //success
}